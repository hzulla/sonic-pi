A.4 Synth Riffs

# Синтезаторные Риффы

Какой бы звук вы не использовали, солирующий синтезатор всегда играет главную
роль в любом электронном треке. В статье из прошлого номера мы рассматривали,
как кодировать барабанные биты. В этой статье мы узнаем, как кодировать три
основных компонента синтезаторных риффов - тембр, мелодию и ритм.

Итак, подключите ваш Paspberry Pi, откройте Sonic Pi версии v2.6+ и давайте
пошумим!

## Тембральные Возможности

Неотъемлемой частью любого синтезаторного риффа является его тембр. Мы можем
изменять тембр в Sonic Pi двумя способами - выбирая различные синты для резкой
смены тембра, и изменяя различные синтовые параметры для более тонкой
настройки. Мы также можем использовать эффекты, но об этом в другой раз...

Давайте создадим простой живой цикл, в котором будет постоянно изменяться
текущий синт:


    live_loop :timbre do
      use_synth (ring :tb303, :blade, :prophet, :saw, :beep, :tri).tick
      play :e2, attack: 0, release: 0.5, cutoff: 100
      sleep 0.5
    end


Взгляните на код. Мы просто перебираем по кругу элементы кольцевого списка,
содержащего имена синтов (цикл переключает синт на следующий в списке снова и
снова). Мы передаём имена этих синтов функции `use_synth`, которая и
переключает текущий синтезатор цикла `live_loop`. Ещё мы играем ноту `:Е2` (ми
второй октавы), со временем затухания 0.5 удара (пол секунды с ВРМ по умолчанию
60) и с параметром `cutoff:`, равным 100.

Слышите, разные синтезаторы  звучат совершенно по-разному, хотя играют одну и
ту же ноту? Теперь давайте поэкспериментируем. Измените время затухания на
большее или меньшее значение. Изменяйте оба параметра - `attack:` и `release:`,
чтобы посмотреть, как сильно разные их значения изменяют звук. Наконец, 
измените параметр `cutoff:`, чтобы услышать, что разные значения среза фильтра
также радикально изменяют тембр синта (значения между 60 и 130 обычно звучат
хорошо). Посмотрите, сколько разнообразных звуков можно создать, изменяя всего
лишь несколько параметров. Как только вы это освоите, откройте вкладку
"Синтезаторы" справочной системы, и взгляните на полный список синтезаторов и
их параметров, чтобы увидеть, какую мощь вы держите в руках.

## Тембр

Тембр - это просто слово, описывающее звук. Если вы сыграете одну и ту же ноту
на разных инструментах, таких как скрипка, гитара, или пианино, высота звука
будет одинаковой, но качество звуков будет разным. Это качество звука - то, что
позволяет вам слышать разницу между пианино и гитарой - и есть тембр.

## Мелодическая Структура

Ещё одним важным аспектом нашего солирующего синтезатора является выбор нот,
которые он будет играть. Если у вас уже есть хорошая мелодическая идея, то вы
можете просто создать кольцо с вашими нотами, и воспроизводить его по кругу:


    live_loop :riff do
      use_synth :prophet
      riff = (ring :e3, :e3, :r, :g3, :r, :r, :r, :a3)
      play riff.tick, release: 0.5, cutoff: 80
      sleep 0.25
    end


Здесь мы поместили нашу мелодию в кольцевой список, содержащий ноты, такие как
`:е3` и паузы, обозначенные `:r`. Затем, мы использовали `.tick`, чтобы
получить повторяющийся рифф.

## Автомелодия

Не всегда бывает легко придумать хороший рифф с нуля. Вместо этого, иногда
проще сказать Sonic Pi играть случайный рифф, и выбрать тот, который понравится
вам больше всего. Для этого нам необходимо объединить три вещи: кольца,
рандомизацю и отправную точку (зерно) рандомизаци. Взгляните на пример:


    live_loop :random_riff do
      use_synth :dsaw
      use_random_seed 3
      notes = (scale :e3, :minor_pentatonic).shuffle
      play notes.tick, release: 0.25, cutoff: 80
      sleep 0.25
    end


Здесь происходит несколько вещей - давайте рассмотрим их по очереди. Во-первых,
мы указли, что используем зерно рандомизаци 3. Что это значит? Ну, смысл в том,
что когда мы устанавливаем зерно, мы можем предсказать, какой будет
рандомизаця в следующий раз. Той же самой, что и в тот раз, когда мы 
устанавливали зерно в 3! Ещё одна вещь, которую полезно знать, что 
перемешивание нот кольца будет произведено тем же способом. В примере выше, мы,
по сути, вызываем "третье перемешивание" из стандартного списка перемешиваний,
который остаётся неизменным всякий раз, когда мы устанавливаем зерно в то же
значение перед перемешиванием. Наконец, мы просто вызываем по кругу наши
перемешанные ноты, чтобы получить рифф.

Вот где начинается веселье. Если мы меняем значение зерно рандомизаци на
другое, скажем 3000, мы получаем совершенно другое перемешивание нот. Так что
теперь очень легко исследовать новые мелодии. Просто выберите список нот,
которые вы хотите перемешать (гаммы представляют собой отличную отправную
точку), а затем выберите зерно рандомизаци, с которого вы хотите начать
перемешивание. Если вам не нравится мелодия, просто измените одну из этих двух
вещей и попробуйте снова. Повторяйте до тех пор, пока вам понравится то, что вы
слышите!

## Псевдо Рандомизация

Случайный выбор в Sonic Pi на самом деле не является случайным, это то, что
обычно называется псевдо рандомизация. Представьте, что вы бросали игральные
кости 100 раз и записывали результат каждого броска на лист бумаги. Sonic Pi
имеет эквивалент этого списка результатов, которые он использует, когда вы 
запрашиваете случайные значения. Только вместо бросков настоящих костей, он
выбирает следующее значение из списка. Настройка зерна рандомизаци - это просто
прыжок в определённое место этого списка.
 
## Поиск Ритма

Ещё один важный аспект нашго риффа, это ритм - т.е. последовательность нот и
пауз. Как мы видели раньше, мы можем использовать `:r` в наших кольцах, чтобы
вставить паузу. Ещё один очень мощный способ - использовать методы колец, но о
них мы поговорим в следующий раз. Сегодня мы будем использовать рандомизацию,
чтобы помочь нам найти подходящий ритм. Вместо того, чтобы играть каждую ноту,
мы можем играть ноту с заданной вероятностью. Давайте посмотрим:


    live_loop :random_riff do
      use_synth :dsaw
      use_random_seed 30
      notes = (scale :e3, :minor_pentatonic).shuffle
      16.times do
        play notes.tick, release: 0.2, cutoff: 90 if one_in(2)
        sleep 0.125
      end
    end


Очень полезно знать функцию `one_in`, которая возвращает нам `true` или `false`
с заданной вероятностью. Здесь мы используем значение 2, поэтому в среднем
один раз каждые два вызова, `one_in` возвратит `true`. Другими словами, она
будет возвращать `true` в 50% случаев. Если использовать более высокие
значения, `false`будет возвращаться чаще, добавляя в рифф больше пауз.

Заметим, что мы добавили повторы `16.times`. Это потому, что мы хотим 
сбрасывать наше зерно рандомизаци каждые 16 нот. Так наш ритм будет повторяться
каждые 16 ударов. Это не влияет на перемешивание, т.к. оно выполняется сразу
после того, как установлено зерно рандомизаци. Мы можем использовать разное
количество повторов для изменения длины риффа. Попробуйте изменить 16 на 8 или
даже на 4 или 3 и посмотрите, как это повлияет на ритм.

## Соберём Всё Вместе

ОК, теперь давайте совместим всё, чему мы научились, в один финальный пример.
Увидимся в следующий раз!

    live_loop :random_riff do
      #  uncomment to bring in:
      #  synth :blade, note: :e4, release: 4, cutoff: 100, amp: 1.5
      use_synth :dsaw
      use_random_seed 43
      notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle.take(8)
      8.times do
        play notes.tick, release: rand(0.5), cutoff: rrand(60, 130) if one_in(2)
        sleep 0.125
      end
    end
     
    live_loop :drums do
      use_random_seed 500
      16.times do
        sample :bd_haus, rate: 2, cutoff: 110 if rand < 0.35
        sleep 0.125
      end
    end
     
    live_loop :bd do
      sample :bd_haus, cutoff: 100, amp: 3
      sleep 0.5
    end
