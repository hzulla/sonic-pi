3.7 Sample Packs

# Sample Packs

**Hinweis: Dieser Abschnitt des Tutorials behandelt den 
fortgeschrittenen Umgang mit großen Verzeichnissen deiner eigenen 
Samples. Das wird nützlich, wenn du eigene Sample Packs heruntergeladen 
oder gekauft hast und diese in Sonic Pi nutzen möchtest.**

**Du kannst diesen Abschnitt überspringen, wenn du mit den 
mitgelieferten Samples zufrieden arbeiten kannst.**

Wenn du mit großen Ordnern externer Samples arbeitest, kann es mühselig 
sein, jedes Mal den vollständigen Pfad eingeben zu müssen, um ein 
individuelles Sample abzuspielen.

Sagen wir, du hast zum Beispiel folgenden Ordner auf deinem Computer:

```
/pfad/zu/meinen/samples/
```

Wenn wir in den Ordner schauen, finden wir folgende Samples: 

* `100_A#_melody1.wav`
* `100_A#_melody2.wav`
* `100_A#_melody3.wav`
* `120_A#_melody4.wav`
* `120_Bb_guit1.wav`
* `120_Bb_piano1.wav`

Üblicherweise können wir den vollständigen Pfad nutzen um das Piano-Sample abzuspielen:

```
sample "/pfad/zu/meinen/samples/120_Bb_piano1.wav"
```

Wenn wir das Gitarren-Sample abspielen wollen können wir ebenfalls den vollständigen Pfad nutzen:

```
sample "/pfad/zu/meinen/samples/120_Bb_guit.wav"
```

Wie auch immer, beide Aufrufe verlangen von uns, dass wir die Namen der 
Samples innerhalb des Verzeichnisses kennen. Was, wenn wir nur schnell 
die einzelnen Samples nacheinander hören wollen?

# Sample Packs indizieren

Wenn wir das erste Sample in einem Verzeichnis abspielen wollen, müssen 
wir nur, wie folgt, den Verzeichnisnamen zum Sample und den Index 0 
eingeben:

```
sample "/pfad/zu/meinen/samples/ , 0"
```

Wir können sogar eine Verküpfung zu unserem Verzeichnis anlegen, indem 
wir eine Variable nutzen.

```
samps = "/pfad/zu/meinen/samples/"
sample samps, 0
```

Wenn wir nun das zweite Sample in unsrem Verzeichnis abspielen wollen, 
müssen lediglich den Index 1 anfügen.

```
samps = "/pfad/zu/meinen/samples/"
sample samps, 1
```

Bachte, dass wir nicht mehr die Namen der Samples im Verzeichnis kennen 
müssen, wir benötigen nur das Verzeichnis (oder haben eine Verknüpfung 
zu diesem). Wenn wir nach einem Index fragen, der größer, als die 
Anzahl der Samples ist, fängt es einfach von vorne an, wie bei Ringen. 
Es ist deshalb garantiert, dass egal welche Nummer wir nutzen, wir ein 
Sample aus dem Verzeichnis bekommen.

# Sample Packs filtern

Gewöhnlich reicht das Indizieren aus, aber manchmal benötigen wir mehr 
Kraft um unsere Samples zu sortieren und zu organisieren. 
Glücklicherweise ergänzen viele Sample-Packs nützliche Informationen in 
ihre Dateinamen. Lass uns noch einmal einen Blick auf die Dateinamen in 
unserem Verzeichnis werfen:

* `100_A#_melody1.wav`
* `100_A#_melody2.wav`
* `100_A#_melody3.wav`
* `120_A#_melody4.wav`
* `120_Bb_guit1.wav`
* `120_Bb_piano1.wav`

Beachte, dass wir in diesen Dateinamen einiges an Informationen haben. 
Zuerst haben wir die BPM (beats per minutes) des Samples. D.h. das 
Piano Sample hat 120 BPM und unsere ersten drei Melodien haben 100 BPM. 
Außerdem, beinhalten unsere Samplenamen die Tonart. Das Gitarren-Sample 
ist in Bb und die Melodien sind in A#. Diese Information ist für das 
Mixen der Samples in unserem Code sehr wichtig. Zum Beispiel wissen 
wir, dass wir das Piano-Sample nur mit Code verwenden können, der 120 
BPM und die Tonart Bb hat.

Es stellt sich heraus, dass wir dies spezielle Namensgebung unserer 
Sample-Sets im Code nutzen können, um uns dabei zu helfen, das 
herauszufiltern, was wir wollen. Wenn wir zum Beispiel mit 120 BPM 
arbeiten, können wir mit folgendem, alle Samples filtern die den String 
"120" haben:

```
samps = "/pfad/zu/meinen/samples/"
sample samps, "120"
```

Dieser Code wird das erste passende Sample abspielen. Wenn wir das 
zweite passene Sample abspielen wollen, müssen wir nur einen Index 
nutzen: 

```
samps = "/pfad/zu/meinen/samples/“
sample samps, "120", 1
```

Wir können sogar mehrere Filter zur selben Zeit nutzen. Wenn wir zum 
Beispiel ein Sample dessen Name sowohl den String "120" und "A#" 
enthält haben wollen, können wir dieses einfach mit folgendem Code 
finden:

```
samps = "/pfad/zu/meinen/samples/"
sample samps, "120", "A#"
```

Letztendlich steht es uns frei, unsere üblichen Optionen beim Aufruf 
des Samples anzuhängen.

```
samps = "/pfad/zu/meinen/samples/"
sample samps, "120", "Bb", 1, lpf: 70, amp: 2
```

## Sources

The sample filter pre-arg system understands two types of information:
sources and filters. Sources are information used to create the list of
potential candidates. A source can take two forms:

1. "/path/to/samples" - a string representing a valid path to a directory 
2. "/path/to/samples/foo.wav" - a string representing a valid path to a sample

The `sample` fn will first gather all sources and use them to create a
large list of candidates. This list is constructed by first adding all
valid paths and then by adding all the valid `.flac`, `.aif`, `.aiff`,
`.wav`, `.wave` files contained within the directories.

For example, take a look at the following code:

```
samps = "/path/to/my/samples/"
samps2 = "/path/to/my/samples2/"
path = "/path/to/my/samples3/foo.wav"

sample samps, samps2, path, 0
```

Here, we're combining the contents of the samples within two directories
and adding a specific sample. If `"/path/to/my/samples/"` contained 3
samples and `"/path/to/my/samples2/"` contained 12, we'd have 16
potential samples to index and filter (3 + 12 + 1).

By default, only the sample files within a directory are gathered into
the candidate list. Sometimes you might have a number of nested folders of
samples you wish to search and filter within. You can therefore do a
recursive search for all samples within all subfolders of a particular
folder by adding `**` to the end of the path:

```
samps = "/path/to/nested/samples/**"
sample samps, 0
```

Take care though as searching through a very large set of folders may
take a long time. However, the contents of all folder sources are
cached, so the delay will only happen the first time.

Finally, note that the sources *must go first*. If no source is given,
then the set of built-in samples will be selected as the default list of
candidates to work with.

## Filters

Once you have a list of candidates you may use the following filtering
types to further reduce the selection:

* `"foo"` Strings will filter on substring occurrence within file name (minus directory path and extension).
* `/fo[oO]/` Regular Expressions will filter on pattern matching of file name (minus directory path and extension).
* `:foo` - Keywords will filter candidates on whether the keyword is a direct match of the filename (minus directory path and extension).
* `lambda{|a| ... }` - Procs with one argument will be treated as a candidate filter or generator function. It will be passed the list of current candidates and must return a new list of candidates (a list of valid paths to sample files).
* `1` - Numbers will select the candidate with that index (wrapping round like a ring if necessary).

For example, we can filter over all the samples in a directory
containing the string `"foo"` and play the first matching sample at half
speed:

```
sample "/path/to/samples", "foo", rate: 0.5
```

See the help for `sample` for many detailed usage examples. Note that
the ordering of the filters is honoured.

## Composites

Finally, you may use lists wherever you may place a source or
filter. The list will be automatically flattened and the contents will
be treated as regular sources and filters. Therefore the following calls
to `sample` are semantically equivalent:

```
sample "/path/to/dir", "100", "C#"
sample ["/path/to/dir", "100", "C#"]
sample "/path/to/dir", ["100", "C#"]
sample ["/path/to/dir", ["100", ["C#"]]]
```

## Wrapping Up

This was an advanced section for people that need real power to
manipulate and use sample packs. If most of this section didn't make too
much sense, don't worry. It's likely you don't need any of this
functionality just yet. However, you'll know when you do need it and you
can come back and re-read this when you start working with large
directories of samples.
